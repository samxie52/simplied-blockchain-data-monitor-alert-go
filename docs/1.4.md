# Step 1.4: æ•°æ®åº“è¿æ¥å±‚å®ç°

## ğŸ“‹ å®ç°ç›®æ ‡

æœ¬æ­¥éª¤å°†å»ºç«‹å®Œæ•´çš„æ•°æ®åº“è¿æ¥å’Œç®¡ç†ç³»ç»Ÿï¼ŒåŒ…æ‹¬ PostgreSQL å’Œ Redis çš„è¿æ¥ç®¡ç†ã€å¥åº·æ£€æŸ¥æœºåˆ¶ï¼Œä»¥åŠæ•°æ®åº“è¿ç§»å·¥å…·ã€‚è¿™ä¸ºæ•´ä¸ªé¡¹ç›®æä¾›äº†å¯é çš„æ•°æ®å­˜å‚¨åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½

### 1. PostgreSQL è¿æ¥ç®¡ç†
- è¿æ¥æ± ç®¡ç†å’Œé…ç½®
- è‡ªåŠ¨é‡è¿æœºåˆ¶
- è¿æ¥å¥åº·æ£€æŸ¥
- äº‹åŠ¡ç®¡ç†æ”¯æŒ
- æŸ¥è¯¢æ€§èƒ½ç›‘æ§

### 2. Redis è¿æ¥ç®¡ç†  
- Redis å®¢æˆ·ç«¯å°è£…
- è¿æ¥æ± ä¼˜åŒ–
- é›†ç¾¤æ”¯æŒå‡†å¤‡
- ç¼“å­˜æ“ä½œå°è£…
- è¿æ¥çŠ¶æ€ç›‘æ§

### 3. æ•°æ®åº“å¥åº·æ£€æŸ¥
- å®šæœŸå¥åº·çŠ¶æ€æ£€æµ‹
- è¿æ¥å¯ç”¨æ€§éªŒè¯
- æ€§èƒ½æŒ‡æ ‡æ”¶é›†
- æ•…éšœè‡ªåŠ¨æ¢å¤

### 4. æ•°æ®åº“è¿ç§»å·¥å…·
- æ•°æ®åº“ç‰ˆæœ¬ç®¡ç†
- è¿ç§»è„šæœ¬æ‰§è¡Œ
- å›æ»šæœºåˆ¶
- è¿ç§»çŠ¶æ€è·Ÿè¸ª

## ğŸ—ï¸ æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "Application Layer"
        APP[Application Services]
        HEALTH[Health Check Service]
        MIGRATOR[Migration Tool]
    end
    
    subgraph "Database Layer"
        PGMGR[PostgreSQL Manager]
        REDISMGR[Redis Manager]
    end
    
    subgraph "Connection Pool"
        PGPOOL[PostgreSQL Pool]
        REDISPOOL[Redis Pool]
    end
    
    subgraph "External Databases"
        PG[(PostgreSQL)]
        REDIS[(Redis)]
    end
    
    subgraph "Monitoring"
        METRICS[Connection Metrics]
        LOGS[Connection Logs]
    end
    
    APP --> PGMGR
    APP --> REDISMGR
    HEALTH --> PGMGR
    HEALTH --> REDISMGR
    MIGRATOR --> PGMGR
    
    PGMGR --> PGPOOL
    REDISMGR --> REDISPOOL
    
    PGPOOL --> PG
    REDISPOOL --> REDIS
    
    PGMGR --> METRICS
    REDISMGR --> METRICS
    PGMGR --> LOGS
    REDISMGR --> LOGS
```

## ğŸ“ æ–‡ä»¶ç»“æ„

```
pkg/database/
â”œâ”€â”€ postgres.go          # PostgreSQL è¿æ¥ç®¡ç†
â”œâ”€â”€ redis.go             # Redis è¿æ¥ç®¡ç†
â”œâ”€â”€ health.go            # æ•°æ®åº“å¥åº·æ£€æŸ¥
â””â”€â”€ migration.go         # è¿ç§»å·¥å…·æ”¯æŒ

cmd/migrator/
â””â”€â”€ main.go              # æ•°æ®åº“è¿ç§»å·¥å…·ä¸»ç¨‹åº

migrations/              # æ•°æ®åº“è¿ç§»è„šæœ¬ç›®å½•
â”œâ”€â”€ 001_initial_schema.up.sql
â”œâ”€â”€ 001_initial_schema.down.sql
â””â”€â”€ README.md
```

## ğŸ”§ ä¾èµ–åŒ…ç®¡ç†

### æ·»åŠ å¿…è¦ä¾èµ–

```bash
# PostgreSQL é©±åŠ¨å’Œ SQL æ‰©å±•
go get github.com/lib/pq
go get github.com/jmoiron/sqlx

# Redis å®¢æˆ·ç«¯
go get github.com/go-redis/redis/v8

# æ•°æ®åº“è¿ç§»å·¥å…·
go get -u github.com/golang-migrate/migrate/v4
go get -u github.com/golang-migrate/migrate/v4/database/postgres
go get -u github.com/golang-migrate/migrate/v4/source/file

# Prometheus æŒ‡æ ‡
go get github.com/prometheus/client_golang/prometheus

# æ—¥å¿—åº“
go get github.com/sirupsen/logrus
```

### æ›´æ–° go.mod

åœ¨é¡¹ç›®æ ¹ç›®å½•æ‰§è¡Œï¼š

```bash
go mod tidy
```

## ğŸ“Š æ•°æ®åº“è¿æ¥æµç¨‹

```mermaid
sequenceDiagram
    participant App as Application
    participant PgMgr as PostgreSQL Manager
    participant RedisMgr as Redis Manager
    participant Health as Health Checker
    participant PG as PostgreSQL
    participant Redis as Redis
    
    App->>PgMgr: Initialize Connection
    PgMgr->>PG: Connect & Test
    PG-->>PgMgr: Connection OK
    
    App->>RedisMgr: Initialize Connection
    RedisMgr->>Redis: Connect & Test
    Redis-->>RedisMgr: Connection OK
    
    App->>Health: Start Health Check
    
    loop Every 30 seconds
        Health->>PgMgr: Ping Database
        PgMgr->>PG: PING
        PG-->>PgMgr: PONG
        PgMgr-->>Health: Status: Healthy
        
        Health->>RedisMgr: Ping Redis
        RedisMgr->>Redis: PING
        Redis-->>RedisMgr: PONG
        RedisMgr-->>Health: Status: Healthy
        
        Health->>Health: Update Overall Status
    end
    
    App->>PgMgr: Execute Query
    PgMgr->>PG: SQL Query
    PG-->>PgMgr: Query Result
    PgMgr-->>App: Result + Metrics
    
    App->>RedisMgr: Cache Operation
    RedisMgr->>Redis: Redis Command
    Redis-->>RedisMgr: Command Result
    RedisMgr-->>App: Result + Metrics
```

## ğŸš€ å®ç°æ­¥éª¤

### Step 1: åˆ›å»º PostgreSQL è¿æ¥ç®¡ç†å™¨

åˆ›å»ºæ–‡ä»¶ `pkg/database/postgres.go`ï¼š

```go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/sirupsen/logrus"

	"simplied-blockchain-data-monitor-alert-go/internal/config"
	"simplied-blockchain-data-monitor-alert-go/pkg/logger"
)

// PostgresManager PostgreSQL è¿æ¥ç®¡ç†å™¨
type PostgresManager struct {
	// æ•°æ®åº“è¿æ¥
	db *sqlx.DB
	// é…ç½®
	config config.DatabaseConfig
	// æ—¥å¿—è®°å½•å™¨
	logger *logger.Logger
	// æŒ‡æ ‡æ”¶é›†å™¨
	metrics *PostgresMetrics
}

// PostgresMetrics PostgreSQL æŒ‡æ ‡
type PostgresMetrics struct {
	// è¿æ¥æ± æŒ‡æ ‡
	ConnectionsActive   prometheus.Gauge
	ConnectionsIdle     prometheus.Gauge
	ConnectionsWaiting  prometheus.Gauge
	// æŸ¥è¯¢æŒ‡æ ‡
	QueriesTotal        *prometheus.CounterVec
	QueryDuration       *prometheus.HistogramVec
	// é”™è¯¯æŒ‡æ ‡
	ErrorsTotal         *prometheus.CounterVec
}

// NewPostgresManager åˆ›å»º PostgreSQL ç®¡ç†å™¨
func NewPostgresManager(cfg config.DatabaseConfig, logger *logger.Logger) (*PostgresManager, error) {
	// æ„å»ºæ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²
	dsn := fmt.Sprintf(
		"host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.Name, cfg.SSLMode,
	)

	// åˆ›å»ºæ•°æ®åº“è¿æ¥
	db, err := sqlx.Connect("postgres", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to PostgreSQL: %w", err)
	}

	// é…ç½®è¿æ¥æ± 
	db.SetMaxOpenConns(cfg.MaxOpenConns)
	db.SetMaxIdleConns(cfg.MaxIdleConns)
	db.SetConnMaxLifetime(cfg.ConnMaxLifetime)

	// åˆ›å»ºæŒ‡æ ‡æ”¶é›†å™¨
	metrics := &PostgresMetrics{
		ConnectionsActive: prometheus.NewGauge(prometheus.GaugeOpts{
			Name: "postgres_connections_active",
			Help: "Number of active PostgreSQL connections",
		}),
		ConnectionsIdle: prometheus.NewGauge(prometheus.GaugeOpts{
			Name: "postgres_connections_idle",
			Help: "Number of idle PostgreSQL connections",
		}),
		ConnectionsWaiting: prometheus.NewGauge(prometheus.GaugeOpts{
			Name: "postgres_connections_waiting",
			Help: "Number of waiting PostgreSQL connections",
		}),
		QueriesTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "postgres_queries_total",
				Help: "Total number of PostgreSQL queries",
			},
			[]string{"operation", "status"},
		),
		QueryDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "postgres_query_duration_seconds",
				Help:    "PostgreSQL query duration in seconds",
				Buckets: []float64{0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0},
			},
			[]string{"operation"},
		),
		ErrorsTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "postgres_errors_total",
				Help: "Total number of PostgreSQL errors",
			},
			[]string{"type"},
		),
	}

	// æ³¨å†ŒæŒ‡æ ‡
	prometheus.MustRegister(
		metrics.ConnectionsActive,
		metrics.ConnectionsIdle,
		metrics.ConnectionsWaiting,
		metrics.QueriesTotal,
		metrics.QueryDuration,
		metrics.ErrorsTotal,
	)

	manager := &PostgresManager{
		db:      db,
		config:  cfg,
		logger:  logger,
		metrics: metrics,
	}

	// å¯åŠ¨æŒ‡æ ‡æ›´æ–°åç¨‹
	go manager.updateMetrics()

	logger.WithFields(logrus.Fields{
		"host": cfg.Host,
		"port": cfg.Port,
		"name": cfg.Name,
	}).Info("PostgreSQL connection established")

	return manager, nil
}

// GetDB è·å–æ•°æ®åº“è¿æ¥
func (pm *PostgresManager) GetDB() *sqlx.DB {
	return pm.db
}

// Ping æ£€æŸ¥æ•°æ®åº“è¿æ¥
func (pm *PostgresManager) Ping(ctx context.Context) error {
	start := time.Now()
	err := pm.db.PingContext(ctx)
	duration := time.Since(start)

	if err != nil {
		pm.metrics.ErrorsTotal.WithLabelValues("ping").Inc()
		pm.logger.WithFields(logrus.Fields{
			"error":    err.Error(),
			"duration": duration.Milliseconds(),
		}).Error("PostgreSQL ping failed")
		return err
	}

	pm.logger.WithFields(logrus.Fields{
		"duration": duration.Milliseconds(),
	}).Debug("PostgreSQL ping successful")

	return nil
}

// Close å…³é—­æ•°æ®åº“è¿æ¥
func (pm *PostgresManager) Close() error {
	if pm.db != nil {
		pm.logger.Info("Closing PostgreSQL connection")
		return pm.db.Close()
	}
	return nil
}

// ExecuteQuery æ‰§è¡ŒæŸ¥è¯¢å¹¶è®°å½•æŒ‡æ ‡
func (pm *PostgresManager) ExecuteQuery(ctx context.Context, operation, query string, args ...interface{}) (*sql.Rows, error) {
	start := time.Now()
	
	rows, err := pm.db.QueryContext(ctx, query, args...)
	duration := time.Since(start)
	
	// è®°å½•æŒ‡æ ‡
	pm.metrics.QueryDuration.WithLabelValues(operation).Observe(duration.Seconds())
	
	if err != nil {
		pm.metrics.QueriesTotal.WithLabelValues(operation, "error").Inc()
		pm.metrics.ErrorsTotal.WithLabelValues("query").Inc()
		
		pm.logger.WithFields(logrus.Fields{
			"operation": operation,
			"error":     err.Error(),
			"duration":  duration.Milliseconds(),
		}).Error("PostgreSQL query failed")
		
		return nil, err
	}
	
	pm.metrics.QueriesTotal.WithLabelValues(operation, "success").Inc()
	
	pm.logger.WithFields(logrus.Fields{
		"operation": operation,
		"duration":  duration.Milliseconds(),
	}).Debug("PostgreSQL query executed")
	
	return rows, nil
}

// BeginTx å¼€å§‹äº‹åŠ¡
func (pm *PostgresManager) BeginTx(ctx context.Context) (*sqlx.Tx, error) {
	tx, err := pm.db.BeginTxx(ctx, nil)
	if err != nil {
		pm.metrics.ErrorsTotal.WithLabelValues("transaction").Inc()
		pm.logger.WithFields(logrus.Fields{
			"error": err.Error(),
		}).Error("Failed to begin PostgreSQL transaction")
		return nil, err
	}
	
	pm.logger.Debug("PostgreSQL transaction started")
	return tx, nil
}

// updateMetrics æ›´æ–°è¿æ¥æ± æŒ‡æ ‡
func (pm *PostgresManager) updateMetrics() {
	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()
	
	for range ticker.C {
		stats := pm.db.Stats()
		pm.metrics.ConnectionsActive.Set(float64(stats.OpenConnections))
		pm.metrics.ConnectionsIdle.Set(float64(stats.Idle))
		pm.metrics.ConnectionsWaiting.Set(float64(stats.WaitCount))
	}
}

// GetStats è·å–è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯
func (pm *PostgresManager) GetStats() sql.DBStats {
	return pm.db.Stats()
}
```

### Step 2: åˆ›å»º Redis è¿æ¥ç®¡ç†å™¨

åˆ›å»ºæ–‡ä»¶ `pkg/database/redis.go`ï¼š

```go
package database

import (
	"context"
	"fmt"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/sirupsen/logrus"

	"simplied-blockchain-data-monitor-alert-go/internal/config"
	"simplied-blockchain-data-monitor-alert-go/pkg/logger"
)

// RedisManager Redis è¿æ¥ç®¡ç†å™¨
type RedisManager struct {
	// Redis å®¢æˆ·ç«¯
	client redis.UniversalClient
	// é…ç½®
	config config.RedisConfig
	// æ—¥å¿—è®°å½•å™¨
	logger *logger.Logger
	// æŒ‡æ ‡æ”¶é›†å™¨
	metrics *RedisMetrics
}

// RedisMetrics Redis æŒ‡æ ‡
type RedisMetrics struct {
	// è¿æ¥æŒ‡æ ‡
	ConnectionsActive   prometheus.Gauge
	ConnectionsIdle     prometheus.Gauge
	// å‘½ä»¤æŒ‡æ ‡
	CommandsTotal       *prometheus.CounterVec
	CommandDuration     *prometheus.HistogramVec
	// é”™è¯¯æŒ‡æ ‡
	ErrorsTotal         *prometheus.CounterVec
	// å†…å­˜æŒ‡æ ‡
	MemoryUsage         prometheus.Gauge
}

// NewRedisManager åˆ›å»º Redis ç®¡ç†å™¨
func NewRedisManager(cfg config.RedisConfig, logger *logger.Logger) (*RedisManager, error) {
	// åˆ›å»º Redis å®¢æˆ·ç«¯é…ç½®
	options := &redis.Options{
		Addr:     fmt.Sprintf("%s:%d", cfg.Host, cfg.Port),
		Password: cfg.Password,
		DB:       cfg.DB,
		PoolSize: cfg.PoolSize,
		
		// è¿æ¥è¶…æ—¶é…ç½®
		DialTimeout:  5 * time.Second,
		ReadTimeout:  3 * time.Second,
		WriteTimeout: 3 * time.Second,
		
		// è¿æ¥æ± é…ç½®
		PoolTimeout:  4 * time.Second,
		IdleTimeout:  5 * time.Minute,
		MaxRetries:   3,
		MinIdleConns: 10,
	}

	// åˆ›å»º Redis å®¢æˆ·ç«¯
	client := redis.NewClient(options)

	// æµ‹è¯•è¿æ¥
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	if err := client.Ping(ctx).Err(); err != nil {
		return nil, fmt.Errorf("failed to connect to Redis: %w", err)
	}

	// åˆ›å»ºæŒ‡æ ‡æ”¶é›†å™¨
	metrics := &RedisMetrics{
		ConnectionsActive: prometheus.NewGauge(prometheus.GaugeOpts{
			Name: "redis_connections_active",
			Help: "Number of active Redis connections",
		}),
		ConnectionsIdle: prometheus.NewGauge(prometheus.GaugeOpts{
			Name: "redis_connections_idle",
			Help: "Number of idle Redis connections",
		}),
		CommandsTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "redis_commands_total",
				Help: "Total number of Redis commands",
			},
			[]string{"command", "status"},
		),
		CommandDuration: prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Name:    "redis_command_duration_seconds",
				Help:    "Redis command duration in seconds",
				Buckets: []float64{0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1, 0.5},
			},
			[]string{"command"},
		),
		ErrorsTotal: prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "redis_errors_total",
				Help: "Total number of Redis errors",
			},
			[]string{"type"},
		),
		MemoryUsage: prometheus.NewGauge(prometheus.GaugeOpts{
			Name: "redis_memory_usage_bytes",
			Help: "Redis memory usage in bytes",
		}),
	}

	// æ³¨å†ŒæŒ‡æ ‡
	prometheus.MustRegister(
		metrics.ConnectionsActive,
		metrics.ConnectionsIdle,
		metrics.CommandsTotal,
		metrics.CommandDuration,
		metrics.ErrorsTotal,
		metrics.MemoryUsage,
	)

	manager := &RedisManager{
		client:  client,
		config:  cfg,
		logger:  logger,
		metrics: metrics,
	}

	// å¯åŠ¨æŒ‡æ ‡æ›´æ–°åç¨‹
	go manager.updateMetrics()

	logger.WithFields(logrus.Fields{
		"host": cfg.Host,
		"port": cfg.Port,
		"db":   cfg.DB,
	}).Info("Redis connection established")

	return manager, nil
}

// GetClient è·å– Redis å®¢æˆ·ç«¯
func (rm *RedisManager) GetClient() redis.UniversalClient {
	return rm.client
}

// Ping æ£€æŸ¥ Redis è¿æ¥
func (rm *RedisManager) Ping(ctx context.Context) error {
	start := time.Now()
	err := rm.client.Ping(ctx).Err()
	duration := time.Since(start)

	if err != nil {
		rm.metrics.ErrorsTotal.WithLabelValues("ping").Inc()
		rm.logger.WithFields(logrus.Fields{
			"error":    err.Error(),
			"duration": duration.Milliseconds(),
		}).Error("Redis ping failed")
		return err
	}

	rm.logger.WithFields(logrus.Fields{
		"duration": duration.Milliseconds(),
	}).Debug("Redis ping successful")

	return nil
}

// Close å…³é—­ Redis è¿æ¥
func (rm *RedisManager) Close() error {
	if rm.client != nil {
		rm.logger.Info("Closing Redis connection")
		return rm.client.Close()
	}
	return nil
}

// Set è®¾ç½®é”®å€¼å¯¹
func (rm *RedisManager) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
	start := time.Now()
	
	err := rm.client.Set(ctx, key, value, expiration).Err()
	duration := time.Since(start)
	
	// è®°å½•æŒ‡æ ‡
	rm.metrics.CommandDuration.WithLabelValues("set").Observe(duration.Seconds())
	
	if err != nil {
		rm.metrics.CommandsTotal.WithLabelValues("set", "error").Inc()
		rm.metrics.ErrorsTotal.WithLabelValues("command").Inc()
		
		rm.logger.WithFields(logrus.Fields{
			"key":      key,
			"error":    err.Error(),
			"duration": duration.Milliseconds(),
		}).Error("Redis SET failed")
		
		return err
	}
	
	rm.metrics.CommandsTotal.WithLabelValues("set", "success").Inc()
	
	rm.logger.WithFields(logrus.Fields{
		"key":      key,
		"duration": duration.Milliseconds(),
	}).Debug("Redis SET executed")
	
	return nil
}

// Get è·å–é”®å€¼
func (rm *RedisManager) Get(ctx context.Context, key string) (string, error) {
	start := time.Now()
	
	result, err := rm.client.Get(ctx, key).Result()
	duration := time.Since(start)
	
	// è®°å½•æŒ‡æ ‡
	rm.metrics.CommandDuration.WithLabelValues("get").Observe(duration.Seconds())
	
	if err != nil {
		if err == redis.Nil {
			rm.metrics.CommandsTotal.WithLabelValues("get", "miss").Inc()
		} else {
			rm.metrics.CommandsTotal.WithLabelValues("get", "error").Inc()
			rm.metrics.ErrorsTotal.WithLabelValues("command").Inc()
		}
		
		rm.logger.WithFields(logrus.Fields{
			"key":      key,
			"error":    err.Error(),
			"duration": duration.Milliseconds(),
		}).Debug("Redis GET failed")
		
		return "", err
	}
	
	rm.metrics.CommandsTotal.WithLabelValues("get", "hit").Inc()
	
	rm.logger.WithFields(logrus.Fields{
		"key":      key,
		"duration": duration.Milliseconds(),
	}).Debug("Redis GET executed")
	
	return result, nil
}

// Delete åˆ é™¤é”®
func (rm *RedisManager) Delete(ctx context.Context, keys ...string) error {
	start := time.Now()
	
	err := rm.client.Del(ctx, keys...).Err()
	duration := time.Since(start)
	
	// è®°å½•æŒ‡æ ‡
	rm.metrics.CommandDuration.WithLabelValues("del").Observe(duration.Seconds())
	
	if err != nil {
		rm.metrics.CommandsTotal.WithLabelValues("del", "error").Inc()
		rm.metrics.ErrorsTotal.WithLabelValues("command").Inc()
		
		rm.logger.WithFields(logrus.Fields{
			"keys":     keys,
			"error":    err.Error(),
			"duration": duration.Milliseconds(),
		}).Error("Redis DEL failed")
		
		return err
	}
	
	rm.metrics.CommandsTotal.WithLabelValues("del", "success").Inc()
	
	rm.logger.WithFields(logrus.Fields{
		"keys":     keys,
		"duration": duration.Milliseconds(),
	}).Debug("Redis DEL executed")
	
	return nil
}

// Exists æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
func (rm *RedisManager) Exists(ctx context.Context, keys ...string) (int64, error) {
	start := time.Now()
	
	result, err := rm.client.Exists(ctx, keys...).Result()
	duration := time.Since(start)
	
	// è®°å½•æŒ‡æ ‡
	rm.metrics.CommandDuration.WithLabelValues("exists").Observe(duration.Seconds())
	
	if err != nil {
		rm.metrics.CommandsTotal.WithLabelValues("exists", "error").Inc()
		rm.metrics.ErrorsTotal.WithLabelValues("command").Inc()
		
		rm.logger.WithFields(logrus.Fields{
			"keys":     keys,
			"error":    err.Error(),
			"duration": duration.Milliseconds(),
		}).Error("Redis EXISTS failed")
		
		return 0, err
	}
	
	rm.metrics.CommandsTotal.WithLabelValues("exists", "success").Inc()
	
	rm.logger.WithFields(logrus.Fields{
		"keys":     keys,
		"result":   result,
		"duration": duration.Milliseconds(),
	}).Debug("Redis EXISTS executed")
	
	return result, nil
}

// updateMetrics æ›´æ–° Redis æŒ‡æ ‡
func (rm *RedisManager) updateMetrics() {
	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()
	
	for range ticker.C {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		
		// è·å–è¿æ¥æ± ç»Ÿè®¡
		poolStats := rm.client.PoolStats()
		rm.metrics.ConnectionsActive.Set(float64(poolStats.TotalConns))
		rm.metrics.ConnectionsIdle.Set(float64(poolStats.IdleConns))
		
		// è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
		if info, err := rm.client.Info(ctx, "memory").Result(); err == nil {
			// è§£æå†…å­˜ä½¿ç”¨ä¿¡æ¯ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
			rm.logger.WithField("memory_info", info).Debug("Redis memory info")
		}
		
		cancel()
	}
}

// GetPoolStats è·å–è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯
func (rm *RedisManager) GetPoolStats() *redis.PoolStats {
    return rm.client.PoolStats()
}
```

### Step 3: åˆ›å»ºæ•°æ®åº“å¥åº·æ£€æŸ¥

åˆ›å»ºæ–‡ä»¶ `pkg/database/health.go`ï¼š

```go
package database

import (
    "context"
    "sync"
    "time"

    "github.com/sirupsen/logrus"

    "simplied-blockchain-data-monitor-alert-go/pkg/logger"
)

// HealthStatus å¥åº·çŠ¶æ€
type HealthStatus struct {
    Healthy bool `json:"healthy"`
    Status string `json:"status"`
    ResponseTime time.Duration `json:"response_time"`
    LastCheck time.Time `json:"last_check"`
    Error string `json:"error,omitempty"`
}

// DatabaseHealth æ•°æ®åº“å¥åº·çŠ¶æ€
type DatabaseHealth struct {
    PostgreSQL HealthStatus `json:"postgresql"`
    Redis HealthStatus `json:"redis"`
    Overall HealthStatus `json:"overall"`
}

// HealthChecker å¥åº·æ£€æŸ¥å™¨
type HealthChecker struct {
    postgres *PostgresManager
    redis *RedisManager
    logger *logger.Logger
    health *DatabaseHealth
    mutex sync.RWMutex
    interval time.Duration
    stopChan chan struct{}
}

// NewHealthChecker åˆ›å»ºå¥åº·æ£€æŸ¥å™¨
func NewHealthChecker(postgres *PostgresManager, redis *RedisManager, logger *logger.Logger) *HealthChecker {
    return &HealthChecker{
        postgres: postgres,
        redis:    redis,
        logger:   logger,
        health: &DatabaseHealth{
            PostgreSQL: HealthStatus{Status: "unknown"},
            Redis:      HealthStatus{Status: "unknown"},
            Overall:    HealthStatus{Status: "unknown"},
        },
        interval: 30 * time.Second,
        stopChan: make(chan struct{}),
    }
}

// Start å¯åŠ¨å¥åº·æ£€æŸ¥
func (hc *HealthChecker) Start() {
    hc.logger.Info("Starting database health checker")
    hc.checkHealth()
    
    ticker := time.NewTicker(hc.interval)
    go func() {
        defer ticker.Stop()
        for {
            select {
            case <-ticker.C:
                hc.checkHealth()
            case <-hc.stopChan:
                hc.logger.Info("Database health checker stopped")
                return
            }
        }
    }()
}

// GetHealth è·å–å¥åº·çŠ¶æ€
func (hc *HealthChecker) GetHealth() DatabaseHealth {
    hc.mutex.RLock()
    defer hc.mutex.RUnlock()
    return *hc.health
}

// checkHealth æ‰§è¡Œå¥åº·æ£€æŸ¥
func (hc *HealthChecker) checkHealth() {
    hc.mutex.Lock()
    defer hc.mutex.Unlock()
    
    now := time.Now()
    
    pgStatus := hc.checkPostgreSQL()
    pgStatus.LastCheck = now
    hc.health.PostgreSQL = pgStatus
    
    redisStatus := hc.checkRedis()
    redisStatus.LastCheck = now
    hc.health.Redis = redisStatus
    
    overall := HealthStatus{
        Healthy:      pgStatus.Healthy && redisStatus.Healthy,
        LastCheck:    now,
        ResponseTime: (pgStatus.ResponseTime + redisStatus.ResponseTime) / 2,
    }
    
    if overall.Healthy {
        overall.Status = "healthy"
    } else {
        overall.Status = "unhealthy"
        if !pgStatus.Healthy && !redisStatus.Healthy {
            overall.Error = "Both PostgreSQL and Redis are unhealthy"
        } else if !pgStatus.Healthy {
            overall.Error = "PostgreSQL is unhealthy"
        } else {
            overall.Error = "Redis is unhealthy"
        }
    }
    
    hc.health.Overall = overall
}

// checkPostgreSQL æ£€æŸ¥ PostgreSQL å¥åº·çŠ¶æ€
func (hc *HealthChecker) checkPostgreSQL() HealthStatus {
    start := time.Now()
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    err := hc.postgres.Ping(ctx)
    responseTime := time.Since(start)
    
    if err != nil {
        return HealthStatus{
            Healthy:      false,
            Status:       "unhealthy",
            ResponseTime: responseTime,
            Error:        err.Error(),
        }
    }
    
    return HealthStatus{
        Healthy:      true,
        Status:       "healthy",
        ResponseTime: responseTime,
    }
}

// checkRedis æ£€æŸ¥ Redis å¥åº·çŠ¶æ€
func (hc *HealthChecker) checkRedis() HealthStatus {
    start := time.Now()
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    err := hc.redis.Ping(ctx)
    responseTime := time.Since(start)
    
    if err != nil {
        return HealthStatus{
            Healthy:      false,
            Status:       "unhealthy",
            ResponseTime: responseTime,
            Error:        err.Error(),
        }
    }
    
    return HealthStatus{
        Healthy:      true,
        Status:       "healthy",
        ResponseTime: responseTime,
    }
}
```

### Step 4: åˆ›å»ºæ•°æ®åº“è¿ç§»å·¥å…·

åˆ›å»ºæ–‡ä»¶ `pkg/database/migration.go`ï¼š

```go
package database

import (
    "database/sql"
    "fmt"
    "path/filepath"

    "github.com/golang-migrate/migrate/v4"
    "github.com/golang-migrate/migrate/v4/database/postgres"
    "github.com/golang-migrate/migrate/v4/source/file"
    "github.com/sirupsen/logrus"

    "simplied-blockchain-data-monitor-alert-go/pkg/logger"
)

// Migrator æ•°æ®åº“è¿ç§»å™¨
type Migrator struct {
    migrate *migrate.Migrate
    logger *logger.Logger
}

// NewMigrator åˆ›å»ºè¿ç§»å™¨
func NewMigrator(db *sql.DB, migrationsPath string, logger *logger.Logger) (*Migrator, error) {
    driver, err := postgres.WithInstance(db, &postgres.Config{})
    if err != nil {
        return nil, fmt.Errorf("failed to create postgres driver: %w", err)
    }

    sourceURL := fmt.Sprintf("file://%s", filepath.Clean(migrationsPath))
    m, err := migrate.NewWithDatabaseInstance(sourceURL, "postgres", driver)
    if err != nil {
        return nil, fmt.Errorf("failed to create migrate instance: %w", err)
    }

    return &Migrator{
        migrate: m,
        logger:  logger,
    }, nil
}

// Up æ‰§è¡Œå‘ä¸Šè¿ç§»
func (m *Migrator) Up() error {
    m.logger.Info("Starting database migration up")
    
    err := m.migrate.Up()
    if err != nil && err != migrate.ErrNoChange {
        m.logger.WithError(err).Error("Migration up failed")
        return fmt.Errorf("migration up failed: %w", err)
    }
    
    if err == migrate.ErrNoChange {
        m.logger.Info("No migrations to apply")
    } else {
        m.logger.Info("Migration up completed successfully")
    }
    
    return nil
}

// Version è·å–å½“å‰è¿ç§»ç‰ˆæœ¬
func (m *Migrator) Version() (uint, bool, error) {
    version, dirty, err := m.migrate.Version()
    if err != nil {
        m.logger.WithError(err).Error("Failed to get migration version")
        return 0, false, fmt.Errorf("failed to get migration version: %w", err)
    }
    
    m.logger.WithFields(logrus.Fields{
        "version": version,
        "dirty":   dirty,
    }).Info("Current migration version")
    
    return version, dirty, nil
}
```

### Step 5: æ›´æ–°è¿ç§»å·¥å…·ä¸»ç¨‹åº

æ›´æ–°æ–‡ä»¶ `cmd/migrator/main.go`ï¼š

```go
package main

import (
    "flag"
    "fmt"
    "os"

    "simplied-blockchain-data-monitor-alert-go/internal/config"
    "simplied-blockchain-data-monitor-alert-go/pkg/database"
    "simplied-blockchain-data-monitor-alert-go/pkg/logger"
)

func main() {
    var (
        command        = flag.String("command", "up", "Migration command: up, version")
        migrationsPath = flag.String("path", "./migrations", "Path to migrations directory")
        configPath     = flag.String("config", ".env", "Path to configuration file")
    )
    flag.Parse()

    // åŠ è½½é…ç½®
    cfg, err := config.Load(*configPath)
    if err != nil {
        fmt.Printf("Failed to load config: %v\n", err)
        os.Exit(1)
    }

    // åˆ›å»ºæ—¥å¿—è®°å½•å™¨
    loggerConfig := logger.Config{
        Level:     "info",
        Format:    "text",
        Output:    "stdout",
        Component: "migrator",
    }
    log, err := logger.New(loggerConfig)
    if err != nil {
        fmt.Printf("Failed to create logger: %v\n", err)
        os.Exit(1)
    }

    // åˆ›å»ºæ•°æ®åº“è¿æ¥
    pgManager, err := database.NewPostgresManager(cfg.Database, log)
    if err != nil {
        log.WithError(err).Fatal("Failed to create PostgreSQL manager")
    }
    defer pgManager.Close()

    // åˆ›å»ºè¿ç§»å™¨
    migrator, err := database.NewMigrator(pgManager.GetDB().DB, *migrationsPath, log)
    if err != nil {
        log.WithError(err).Fatal("Failed to create migrator")
    }

    // æ‰§è¡Œè¿ç§»å‘½ä»¤
    switch *command {
    case "up":
        if err := migrator.Up(); err != nil {
            log.WithError(err).Fatal("Migration up failed")
        }
        log.Info("Migration up completed")

    case "version":
        v, dirty, err := migrator.Version()
        if err != nil {
            log.WithError(err).Fatal("Failed to get migration version")
        }
        fmt.Printf("Current version: %d, Dirty: %t\n", v, dirty)

    default:
        log.Fatal("Unknown command: " + *command)
    }
}
```

## ğŸ“ åˆ›å»ºè¿ç§»è„šæœ¬ç›®å½•

### åˆ›å»ºè¿ç§»è„šæœ¬ç›®å½•ç»“æ„

```bash
mkdir -p migrations
```

### ç¤ºä¾‹è¿ç§»è„šæœ¬

**æ–‡ä»¶**: `migrations/001_initial_schema.up.sql`

```sql
-- åˆ›å»ºç”¨æˆ·è¡¨
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    telegram_id BIGINT UNIQUE NOT NULL,
    username VARCHAR(255),
    first_name VARCHAR(255),
    last_name VARCHAR(255),
    language_code VARCHAR(10) DEFAULT 'en',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- åˆ›å»ºå‘Šè­¦è§„åˆ™è¡¨
CREATE TABLE IF NOT EXISTS alert_rules (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    rule_type VARCHAR(50) NOT NULL,
    conditions JSONB NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- åˆ›å»ºå‘Šè­¦è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS alerts (
    id SERIAL PRIMARY KEY,
    rule_id INTEGER REFERENCES alert_rules(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    severity VARCHAR(20) DEFAULT 'info',
    status VARCHAR(20) DEFAULT 'pending',
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_users_telegram_id ON users(telegram_id);
CREATE INDEX IF NOT EXISTS idx_alert_rules_user_id ON alert_rules(user_id);
CREATE INDEX IF NOT EXISTS idx_alerts_rule_id ON alerts(rule_id);
```

**æ–‡ä»¶**: `migrations/001_initial_schema.down.sql`

```sql
-- åˆ é™¤ç´¢å¼•
DROP INDEX IF EXISTS idx_alerts_rule_id;
DROP INDEX IF EXISTS idx_alert_rules_user_id;
DROP INDEX IF EXISTS idx_users_telegram_id;

-- åˆ é™¤è¡¨
DROP TABLE IF EXISTS alerts;
DROP TABLE IF EXISTS alert_rules;
DROP TABLE IF EXISTS users;
```

## ğŸ§ª æµ‹è¯•å’ŒéªŒè¯

### 1. æµ‹è¯•æ•°æ®åº“è¿æ¥

åˆ›å»ºæµ‹è¯•æ–‡ä»¶ `test_database.go`ï¼š

```go
package main

import (
    "context"
    "fmt"
    "time"

    "simplied-blockchain-data-monitor-alert-go/internal/config"
    "simplied-blockchain-data-monitor-alert-go/pkg/database"
    "simplied-blockchain-data-monitor-alert-go/pkg/logger"
)

func main() {
    // åŠ è½½é…ç½®
    cfg, err := config.Load(".env")
    if err != nil {
        panic(err)
    }

    // åˆ›å»ºæ—¥å¿—è®°å½•å™¨
    loggerConfig := logger.Config{
        Level:     "info",
        Format:    "text",
        Output:    "stdout",
        Component: "test",
    }
    log, err := logger.New(loggerConfig)
    if err != nil {
        panic(err)
    }

    // æµ‹è¯• PostgreSQL è¿æ¥
    fmt.Println("Testing PostgreSQL connection...")
    pgManager, err := database.NewPostgresManager(cfg.Database, log)
    if err != nil {
        panic(err)
    }
    defer pgManager.Close()

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := pgManager.Ping(ctx); err != nil {
        panic(err)
    }
    fmt.Println("âœ… PostgreSQL connection successful")

    // æµ‹è¯• Redis è¿æ¥
    fmt.Println("Testing Redis connection...")
    redisManager, err := database.NewRedisManager(cfg.Redis, log)
    if err != nil {
        panic(err)
    }
    defer redisManager.Close()

    if err := redisManager.Ping(ctx); err != nil {
        panic(err)
    }
    fmt.Println("âœ… Redis connection successful")

    // æµ‹è¯•å¥åº·æ£€æŸ¥
    fmt.Println("Testing health checker...")
    healthChecker := database.NewHealthChecker(pgManager, redisManager, log)
    healthChecker.Start()
    
    time.Sleep(2 * time.Second)
    health := healthChecker.GetHealth()
    
    fmt.Printf("PostgreSQL: %s (Response: %dms)\n", 
        health.PostgreSQL.Status, 
        health.PostgreSQL.ResponseTime.Milliseconds())
    fmt.Printf("Redis: %s (Response: %dms)\n", 
        health.Redis.Status, 
        health.Redis.ResponseTime.Milliseconds())
    fmt.Printf("Overall: %s\n", health.Overall.Status)
    
    if health.Overall.Healthy {
        fmt.Println("âœ… All database connections are healthy")
    } else {
        fmt.Println("âŒ Some database connections are unhealthy")
    }
}
```

### 2. è¿è¡Œæµ‹è¯•

```bash
# ç¼–è¯‘å¹¶è¿è¡Œæµ‹è¯•
go run test_database.go

# è¿è¡Œæ•°æ®åº“è¿ç§»
go run cmd/migrator/main.go -command=up

# æ£€æŸ¥è¿ç§»ç‰ˆæœ¬
go run cmd/migrator/main.go -command=version
```

## ğŸ“‹ å®Œæˆæ£€æŸ¥æ¸…å•

- âœ… PostgreSQL è¿æ¥ç®¡ç†å™¨å®ç°
- âœ… Redis è¿æ¥ç®¡ç†å™¨å®ç°
- âœ… æ•°æ®åº“å¥åº·æ£€æŸ¥å®ç°
- âœ… æ•°æ®åº“è¿ç§»å·¥å…·å®ç°
- âœ… è¿ç§»è„šæœ¬ç¤ºä¾‹åˆ›å»º
- âœ… è¿æ¥æ± é…ç½®å’Œç›‘æ§
- âœ… Prometheus æŒ‡æ ‡é›†æˆ
- âœ… é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- âœ… æµ‹è¯•å’ŒéªŒè¯æ­¥éª¤

## ğŸ¯ ä¸‹ä¸€æ­¥è®¡åˆ’

å®Œæˆ Step 1.4 åï¼Œå¯ä»¥ç»§ç»­è¿›è¡Œï¼š

1. **Step 2.1**: æ•°æ®æ¨¡å‹è®¾è®¡ - å®šä¹‰æ ¸å¿ƒä¸šåŠ¡æ•°æ®ç»“æ„
2. **Step 2.2**: ä»¥å¤ªåŠå®¢æˆ·ç«¯é›†æˆ - å»ºç«‹ä¸åŒºå—é“¾ç½‘ç»œçš„è¿æ¥
3. **å•å…ƒæµ‹è¯•**: ä¸ºæ•°æ®åº“è¿æ¥å±‚ç¼–å†™å®Œæ•´çš„å•å…ƒæµ‹è¯•
4. **é›†æˆæµ‹è¯•**: æµ‹è¯•æ•°æ®åº“è¿æ¥åœ¨çœŸå®ç¯å¢ƒä¸­çš„è¡¨ç°

## ğŸ’¡ æœ€ä½³å®è·µæ€»ç»“

### è¿æ¥ç®¡ç†
- ä½¿ç”¨è¿æ¥æ± ä¼˜åŒ–æ€§èƒ½
- å®ç°è‡ªåŠ¨é‡è¿æœºåˆ¶
- é…ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
- ç›‘æ§è¿æ¥æ± çŠ¶æ€

### å¥åº·æ£€æŸ¥
- å®šæœŸæ£€æŸ¥æ•°æ®åº“è¿æ¥çŠ¶æ€
- æä¾›è¯¦ç»†çš„å¥åº·çŠ¶æ€ä¿¡æ¯
- æ”¯æŒä¼˜é›…çš„æ•…éšœæ¢å¤
- é›†æˆåˆ°ç›‘æ§ç³»ç»Ÿ

### æ•°æ®åº“è¿ç§»
- ä½¿ç”¨ç‰ˆæœ¬åŒ–çš„è¿ç§»è„šæœ¬
- æ”¯æŒå‘ä¸Šå’Œå‘ä¸‹è¿ç§»
- æä¾›è¿ç§»çŠ¶æ€æŸ¥è¯¢
- ç¡®ä¿è¿ç§»çš„åŸå­æ€§

### ç›‘æ§å’Œæ—¥å¿—
- æ”¶é›†è¯¦ç»†çš„æ€§èƒ½æŒ‡æ ‡
- è®°å½•æ‰€æœ‰æ•°æ®åº“æ“ä½œ
- æä¾› Prometheus å…¼å®¹æŒ‡æ ‡
- æ”¯æŒç»“æ„åŒ–æ—¥å¿—è®°å½•

---

ğŸ‰ **Step 1.4 æ•°æ®åº“è¿æ¥å±‚å®ç°å®Œæˆï¼**

è¿™ä¸ªå®ç°ä¸ºæ•´ä¸ªé¡¹ç›®æä¾›äº†å¯é çš„æ•°æ®å­˜å‚¨åŸºç¡€ï¼ŒåŒ…æ‹¬é«˜æ€§èƒ½çš„è¿æ¥ç®¡ç†ã€å…¨é¢çš„å¥åº·ç›‘æ§ã€çµæ´»çš„è¿ç§»å·¥å…·ï¼Œä»¥åŠå®Œæ•´çš„å¯è§‚æµ‹æ€§æ”¯æŒã€‚
