# Step 1.2: é…ç½®ç®¡ç†ç³»ç»Ÿ

## ğŸ“‹ ä»»åŠ¡æ¦‚è¿°

**åŠŸèƒ½**: å®ç°ç»Ÿä¸€çš„é…ç½®ç®¡ç†  
**ç›®æ ‡**: å»ºç«‹ä¸€ä¸ªçµæ´»ã€å®‰å…¨ã€æ˜“ç»´æŠ¤çš„é…ç½®ç®¡ç†ç³»ç»Ÿï¼Œæ”¯æŒç¯å¢ƒå˜é‡ã€é…ç½®æ–‡ä»¶å’Œé…ç½®éªŒè¯

## ğŸ¯ å®ç°ç›®æ ‡

1. âœ… è®¾è®¡é…ç½®ç»“æ„ä½“ (internal/config/config.go)
2. âœ… å®ç°ç¯å¢ƒå˜é‡åŠ è½½ (internal/config/env.go)
3. âœ… åˆ›å»ºé…ç½®éªŒè¯æœºåˆ¶
4. âœ… æ›´æ–°é…ç½®æ–‡ä»¶æ¨¡æ¿ (.env.example)

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### é…ç½®ç®¡ç†æ¶æ„
```
internal/config/
â”œâ”€â”€ config.go          # é…ç½®ç»“æ„ä½“å®šä¹‰
â”œâ”€â”€ env.go             # ç¯å¢ƒå˜é‡åŠ è½½å™¨
â”œâ”€â”€ validator.go       # é…ç½®éªŒè¯å™¨
â””â”€â”€ loader.go          # é…ç½®åŠ è½½å™¨
```

## ğŸš€ å®æ–½æ­¥éª¤

### æ­¥éª¤ 1: åˆ›å»ºé…ç½®ç»“æ„ä½“

#### 1.1 åˆ›å»º internal/config/config.go
```go
package config

import (
	"time"
)

// Config åº”ç”¨ç¨‹åºé…ç½®ç»“æ„
type Config struct {
	App       AppConfig       `json:"app"`
	Database  DatabaseConfig  `json:"database"`
	Redis     RedisConfig     `json:"redis"`
	InfluxDB  InfluxDBConfig  `json:"influxdb"`
	Ethereum  EthereumConfig  `json:"ethereum"`
	Telegram  TelegramConfig  `json:"telegram"`
	Monitor   MonitorConfig   `json:"monitor"`
	Logging   LoggingConfig   `json:"logging"`
	Security  SecurityConfig  `json:"security"`
	RateLimit RateLimitConfig `json:"rate_limit"`
	Alert     AlertConfig     `json:"alert"`
	Worker    WorkerConfig    `json:"worker"`
}

// AppConfig åº”ç”¨ç¨‹åºåŸºç¡€é…ç½®
type AppConfig struct {
	Name        string `json:"name" env:"APP_NAME" validate:"required"`
	Version     string `json:"version" env:"APP_VERSION" validate:"required"`
	Environment string `json:"environment" env:"APP_ENV" validate:"required,oneof=development staging production"`
	Port        int    `json:"port" env:"APP_PORT" validate:"required,min=1,max=65535"`
	Host        string `json:"host" env:"APP_HOST" validate:"required"`
	Debug       bool   `json:"debug" env:"APP_DEBUG"`
}

// DatabaseConfig æ•°æ®åº“é…ç½®
type DatabaseConfig struct {
	Host            string        `json:"host" env:"DB_HOST" validate:"required"`
	Port            int           `json:"port" env:"DB_PORT" validate:"required,min=1,max=65535"`
	Name            string        `json:"name" env:"DB_NAME" validate:"required"`
	User            string        `json:"user" env:"DB_USER" validate:"required"`
	Password        string        `json:"password" env:"DB_PASSWORD" validate:"required"`
	SSLMode         string        `json:"ssl_mode" env:"DB_SSL_MODE" validate:"oneof=disable require verify-ca verify-full"`
	MaxOpenConns    int           `json:"max_open_conns" env:"DB_MAX_OPEN_CONNS" validate:"min=1"`
	MaxIdleConns    int           `json:"max_idle_conns" env:"DB_MAX_IDLE_CONNS" validate:"min=1"`
	ConnMaxLifetime time.Duration `json:"conn_max_lifetime" env:"DB_CONN_MAX_LIFETIME"`
}

// RedisConfig Redisé…ç½®
type RedisConfig struct {
	Host     string `json:"host" env:"REDIS_HOST" validate:"required"`
	Port     int    `json:"port" env:"REDIS_PORT" validate:"required,min=1,max=65535"`
	Password string `json:"password" env:"REDIS_PASSWORD"`
	DB       int    `json:"db" env:"REDIS_DB" validate:"min=0,max=15"`
	PoolSize int    `json:"pool_size" env:"REDIS_POOL_SIZE" validate:"min=1"`
}

// InfluxDBConfig InfluxDBé…ç½®
type InfluxDBConfig struct {
	URL    string `json:"url" env:"INFLUX_URL" validate:"required,url"`
	Token  string `json:"token" env:"INFLUX_TOKEN" validate:"required"`
	Org    string `json:"org" env:"INFLUX_ORG" validate:"required"`
	Bucket string `json:"bucket" env:"INFLUX_BUCKET" validate:"required"`
}

// EthereumConfig ä»¥å¤ªåŠé…ç½®
type EthereumConfig struct {
	RPCURL   string `json:"rpc_url" env:"ETH_RPC_URL" validate:"required"`
	HTTPURL  string `json:"http_url" env:"ETH_HTTP_URL" validate:"required,url"`
	Network  string `json:"network" env:"ETH_NETWORK" validate:"required,oneof=mainnet goerli sepolia"`
	ChainID  int64  `json:"chain_id" env:"ETH_CHAIN_ID" validate:"required"`
	Timeout  time.Duration `json:"timeout" env:"ETH_TIMEOUT"`
}

// TelegramConfig Telegram Boté…ç½®
type TelegramConfig struct {
	BotToken   string `json:"bot_token" env:"TELEGRAM_BOT_TOKEN" validate:"required"`
	WebhookURL string `json:"webhook_url" env:"TELEGRAM_WEBHOOK_URL" validate:"url"`
	Timeout    time.Duration `json:"timeout" env:"TELEGRAM_TIMEOUT"`
}

// MonitorConfig ç›‘æ§é…ç½®
type MonitorConfig struct {
	PrometheusPort int    `json:"prometheus_port" env:"PROMETHEUS_PORT" validate:"min=1,max=65535"`
	MetricsPath    string `json:"metrics_path" env:"METRICS_PATH" validate:"required"`
}

// LoggingConfig æ—¥å¿—é…ç½®
type LoggingConfig struct {
	Level    string `json:"level" env:"LOG_LEVEL" validate:"required,oneof=debug info warn error fatal panic"`
	Format   string `json:"format" env:"LOG_FORMAT" validate:"required,oneof=json text"`
	Output   string `json:"output" env:"LOG_OUTPUT" validate:"required,oneof=stdout stderr file"`
	FilePath string `json:"file_path" env:"LOG_FILE_PATH"`
}

// SecurityConfig å®‰å…¨é…ç½®
type SecurityConfig struct {
	JWTSecret           string   `json:"jwt_secret" env:"JWT_SECRET" validate:"required,min=32"`
	APIKey              string   `json:"api_key" env:"API_KEY" validate:"required"`
	CORSAllowedOrigins  []string `json:"cors_allowed_origins" env:"CORS_ALLOWED_ORIGINS"`
	EncryptionKey       string   `json:"encryption_key" env:"ENCRYPTION_KEY" validate:"min=32"`
}

// RateLimitConfig é™æµé…ç½®
type RateLimitConfig struct {
	Requests int           `json:"requests" env:"RATE_LIMIT_REQUESTS" validate:"min=1"`
	Window   time.Duration `json:"window" env:"RATE_LIMIT_WINDOW" validate:"required"`
}

// AlertConfig å‘Šè­¦é…ç½®
type AlertConfig struct {
	Cooldown        time.Duration `json:"cooldown" env:"ALERT_COOLDOWN" validate:"required"`
	MaxPerHour      int           `json:"max_per_hour" env:"MAX_ALERTS_PER_HOUR" validate:"min=1"`
	RetryAttempts   int           `json:"retry_attempts" env:"ALERT_RETRY_ATTEMPTS"`
	RetryInterval   time.Duration `json:"retry_interval" env:"ALERT_RETRY_INTERVAL"`
}

// WorkerConfig å·¥ä½œè¿›ç¨‹é…ç½®
type WorkerConfig struct {
	PoolSize   int           `json:"pool_size" env:"WORKER_POOL_SIZE" validate:"min=1"`
	QueueSize  int           `json:"queue_size" env:"WORKER_QUEUE_SIZE" validate:"min=1"`
	Timeout    time.Duration `json:"timeout" env:"WORKER_TIMEOUT" validate:"required"`
	BatchSize  int           `json:"batch_size" env:"WORKER_BATCH_SIZE"`
}

// GetDSN è·å–æ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²
func (d *DatabaseConfig) GetDSN() string {
	return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		d.Host, d.Port, d.User, d.Password, d.Name, d.SSLMode)
}

// GetRedisAddr è·å–Redisåœ°å€
func (r *RedisConfig) GetRedisAddr() string {
	return fmt.Sprintf("%s:%d", r.Host, r.Port)
}

// IsProduction åˆ¤æ–­æ˜¯å¦ä¸ºç”Ÿäº§ç¯å¢ƒ
func (a *AppConfig) IsProduction() bool {
	return a.Environment == "production"
}

// IsDevelopment åˆ¤æ–­æ˜¯å¦ä¸ºå¼€å‘ç¯å¢ƒ
func (a *AppConfig) IsDevelopment() bool {
	return a.Environment == "development"
}
```

### æ­¥éª¤ 2: å®ç°ç¯å¢ƒå˜é‡åŠ è½½å™¨

#### 2.1 åˆ›å»º internal/config/env.go
```go
package config

import (
	"fmt"
	"os"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/joho/godotenv"
)

// EnvLoader ç¯å¢ƒå˜é‡åŠ è½½å™¨
type EnvLoader struct {
	envFile string
}

// NewEnvLoader åˆ›å»ºç¯å¢ƒå˜é‡åŠ è½½å™¨
func NewEnvLoader(envFile string) *EnvLoader {
	return &EnvLoader{
		envFile: envFile,
	}
}

// Load åŠ è½½ç¯å¢ƒå˜é‡åˆ°é…ç½®ç»“æ„ä½“
func (e *EnvLoader) Load(cfg *Config) error {
	// åŠ è½½.envæ–‡ä»¶
	if e.envFile != "" {
		if err := godotenv.Load(e.envFile); err != nil {
			// .envæ–‡ä»¶ä¸å­˜åœ¨æ—¶ä¸æŠ¥é”™ï¼Œä½¿ç”¨ç³»ç»Ÿç¯å¢ƒå˜é‡
			if !os.IsNotExist(err) {
				return fmt.Errorf("failed to load env file %s: %w", e.envFile, err)
			}
		}
	}

	// ä½¿ç”¨åå°„å¡«å……é…ç½®ç»“æ„ä½“
	return e.fillStruct(reflect.ValueOf(cfg).Elem())
}

// fillStruct é€’å½’å¡«å……ç»“æ„ä½“å­—æ®µ
func (e *EnvLoader) fillStruct(v reflect.Value) error {
	t := v.Type()

	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldType := t.Field(i)

		// è·³è¿‡éå¯¼å‡ºå­—æ®µ
		if !field.CanSet() {
			continue
		}

		// å¤„ç†åµŒå¥—ç»“æ„ä½“
		if field.Kind() == reflect.Struct {
			if err := e.fillStruct(field); err != nil {
				return err
			}
			continue
		}

		// è·å–envæ ‡ç­¾
		envTag := fieldType.Tag.Get("env")
		if envTag == "" {
			continue
		}

		// è·å–ç¯å¢ƒå˜é‡å€¼
		envValue := os.Getenv(envTag)
		if envValue == "" {
			continue
		}

		// æ ¹æ®å­—æ®µç±»å‹è®¾ç½®å€¼
		if err := e.setFieldValue(field, envValue); err != nil {
			return fmt.Errorf("failed to set field %s: %w", fieldType.Name, err)
		}
	}

	return nil
}

// setFieldValue è®¾ç½®å­—æ®µå€¼
func (e *EnvLoader) setFieldValue(field reflect.Value, value string) error {
	switch field.Kind() {
	case reflect.String:
		field.SetString(value)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		if field.Type() == reflect.TypeOf(time.Duration(0)) {
			// å¤„ç†time.Durationç±»å‹
			duration, err := time.ParseDuration(value)
			if err != nil {
				return fmt.Errorf("invalid duration format: %s", value)
			}
			field.SetInt(int64(duration))
		} else {
			intValue, err := strconv.ParseInt(value, 10, 64)
			if err != nil {
				return fmt.Errorf("invalid integer format: %s", value)
			}
			field.SetInt(intValue)
		}
	case reflect.Bool:
		boolValue, err := strconv.ParseBool(value)
		if err != nil {
			return fmt.Errorf("invalid boolean format: %s", value)
		}
		field.SetBool(boolValue)
	case reflect.Slice:
		if field.Type().Elem().Kind() == reflect.String {
			// å¤„ç†å­—ç¬¦ä¸²åˆ‡ç‰‡
			values := strings.Split(value, ",")
			for i, v := range values {
				values[i] = strings.TrimSpace(v)
			}
			field.Set(reflect.ValueOf(values))
		}
	default:
		return fmt.Errorf("unsupported field type: %s", field.Kind())
	}

	return nil
}
```

### æ­¥éª¤ 3: åˆ›å»ºé…ç½®éªŒè¯å™¨

#### 3.1 åˆ›å»º internal/config/validator.go
```go
package config

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/go-playground/validator/v10"
)

// Validator é…ç½®éªŒè¯å™¨
type Validator struct {
	validator *validator.Validate
}

// NewValidator åˆ›å»ºé…ç½®éªŒè¯å™¨
func NewValidator() *Validator {
	v := validator.New()
	
	// æ³¨å†Œè‡ªå®šä¹‰éªŒè¯è§„åˆ™
	v.RegisterValidation("oneof", validateOneOf)
	
	return &Validator{
		validator: v,
	}
}

// Validate éªŒè¯é…ç½®
func (v *Validator) Validate(cfg *Config) error {
	if err := v.validator.Struct(cfg); err != nil {
		return v.formatValidationError(err)
	}
	
	// è‡ªå®šä¹‰éªŒè¯é€»è¾‘
	return v.customValidation(cfg)
}

// formatValidationError æ ¼å¼åŒ–éªŒè¯é”™è¯¯
func (v *Validator) formatValidationError(err error) error {
	var errors []string
	
	for _, err := range err.(validator.ValidationErrors) {
		field := err.Field()
		tag := err.Tag()
		param := err.Param()
		
		var message string
		switch tag {
		case "required":
			message = fmt.Sprintf("%s is required", field)
		case "min":
			message = fmt.Sprintf("%s must be at least %s", field, param)
		case "max":
			message = fmt.Sprintf("%s must be at most %s", field, param)
		case "oneof":
			message = fmt.Sprintf("%s must be one of: %s", field, param)
		case "url":
			message = fmt.Sprintf("%s must be a valid URL", field)
		default:
			message = fmt.Sprintf("%s validation failed for tag '%s'", field, tag)
		}
		
		errors = append(errors, message)
	}
	
	return fmt.Errorf("configuration validation failed: %s", strings.Join(errors, "; "))
}

// customValidation è‡ªå®šä¹‰éªŒè¯é€»è¾‘
func (v *Validator) customValidation(cfg *Config) error {
	// éªŒè¯æ•°æ®åº“è¿æ¥æ± é…ç½®
	if cfg.Database.MaxIdleConns > cfg.Database.MaxOpenConns {
		return fmt.Errorf("database max_idle_conns cannot be greater than max_open_conns")
	}
	
	// éªŒè¯ä»¥å¤ªåŠç½‘ç»œå’Œé“¾IDåŒ¹é…
	if err := v.validateEthereumConfig(&cfg.Ethereum); err != nil {
		return err
	}
	
	// éªŒè¯æ—¥å¿—é…ç½®
	if cfg.Logging.Output == "file" && cfg.Logging.FilePath == "" {
		return fmt.Errorf("log_file_path is required when log_output is 'file'")
	}
	
	// éªŒè¯å®‰å…¨é…ç½®
	if len(cfg.Security.JWTSecret) < 32 {
		return fmt.Errorf("jwt_secret must be at least 32 characters long")
	}
	
	return nil
}

// validateEthereumConfig éªŒè¯ä»¥å¤ªåŠé…ç½®
func (v *Validator) validateEthereumConfig(cfg *EthereumConfig) error {
	networkChainMap := map[string]int64{
		"mainnet": 1,
		"goerli":  5,
		"sepolia": 11155111,
	}
	
	expectedChainID, exists := networkChainMap[cfg.Network]
	if !exists {
		return fmt.Errorf("unsupported ethereum network: %s", cfg.Network)
	}
	
	if cfg.ChainID != expectedChainID {
		return fmt.Errorf("chain_id %d does not match network %s (expected %d)", 
			cfg.ChainID, cfg.Network, expectedChainID)
	}
	
	return nil
}

// validateOneOf è‡ªå®šä¹‰oneoféªŒè¯å™¨
func validateOneOf(fl validator.FieldLevel) bool {
	value := fl.Field().String()
	param := fl.Param()
	
	options := strings.Split(param, " ")
	for _, option := range options {
		if value == option {
			return true
		}
	}
	
	return false
}
```

### æ­¥éª¤ 4: åˆ›å»ºé…ç½®åŠ è½½å™¨

#### 4.1 åˆ›å»º internal/config/loader.go
```go
package config

import (
	"fmt"
	"os"
)

// Loader é…ç½®åŠ è½½å™¨
type Loader struct {
	envLoader *EnvLoader
	validator *Validator
}

// NewLoader åˆ›å»ºé…ç½®åŠ è½½å™¨
func NewLoader(envFile string) *Loader {
	return &Loader{
		envLoader: NewEnvLoader(envFile),
		validator: NewValidator(),
	}
}

// Load åŠ è½½å¹¶éªŒè¯é…ç½®
func (l *Loader) Load() (*Config, error) {
	cfg := &Config{}
	
	// è®¾ç½®é»˜è®¤å€¼
	l.setDefaults(cfg)
	
	// åŠ è½½ç¯å¢ƒå˜é‡
	if err := l.envLoader.Load(cfg); err != nil {
		return nil, fmt.Errorf("failed to load environment variables: %w", err)
	}
	
	// éªŒè¯é…ç½®
	if err := l.validator.Validate(cfg); err != nil {
		return nil, fmt.Errorf("configuration validation failed: %w", err)
	}
	
	return cfg, nil
}

// setDefaults è®¾ç½®é»˜è®¤é…ç½®å€¼
func (l *Loader) setDefaults(cfg *Config) {
	// åº”ç”¨ç¨‹åºé»˜è®¤é…ç½®
	cfg.App.Name = "blockchain-monitor"
	cfg.App.Version = "v1.0.0"
	cfg.App.Environment = "development"
	cfg.App.Port = 8080
	cfg.App.Host = "localhost"
	cfg.App.Debug = false
	
	// æ•°æ®åº“é»˜è®¤é…ç½®
	cfg.Database.Host = "localhost"
	cfg.Database.Port = 5432
	cfg.Database.SSLMode = "disable"
	cfg.Database.MaxOpenConns = 25
	cfg.Database.MaxIdleConns = 5
	cfg.Database.ConnMaxLifetime = 300 * time.Second
	
	// Redisé»˜è®¤é…ç½®
	cfg.Redis.Host = "localhost"
	cfg.Redis.Port = 6379
	cfg.Redis.DB = 0
	cfg.Redis.PoolSize = 10
	
	// ä»¥å¤ªåŠé»˜è®¤é…ç½®
	cfg.Ethereum.Network = "mainnet"
	cfg.Ethereum.ChainID = 1
	cfg.Ethereum.Timeout = 30 * time.Second
	
	// Telegramé»˜è®¤é…ç½®
	cfg.Telegram.Timeout = 30 * time.Second
	
	// ç›‘æ§é»˜è®¤é…ç½®
	cfg.Monitor.PrometheusPort = 9090
	cfg.Monitor.MetricsPath = "/metrics"
	
	// æ—¥å¿—é»˜è®¤é…ç½®
	cfg.Logging.Level = "info"
	cfg.Logging.Format = "json"
	cfg.Logging.Output = "stdout"
	
	// é™æµé»˜è®¤é…ç½®
	cfg.RateLimit.Requests = 100
	cfg.RateLimit.Window = 60 * time.Second
	
	// å‘Šè­¦é»˜è®¤é…ç½®
	cfg.Alert.Cooldown = 300 * time.Second
	cfg.Alert.MaxPerHour = 10
	cfg.Alert.RetryAttempts = 3
	cfg.Alert.RetryInterval = 30 * time.Second
	
	// å·¥ä½œè¿›ç¨‹é»˜è®¤é…ç½®
	cfg.Worker.PoolSize = 10
	cfg.Worker.QueueSize = 1000
	cfg.Worker.Timeout = 30 * time.Second
	cfg.Worker.BatchSize = 100
}

// MustLoad åŠ è½½é…ç½®ï¼Œå¤±è´¥æ—¶panic
func (l *Loader) MustLoad() *Config {
	cfg, err := l.Load()
	if err != nil {
		panic(fmt.Sprintf("Failed to load configuration: %v", err))
	}
	return cfg
}

// LoadFromFile ä»æŒ‡å®šæ–‡ä»¶åŠ è½½é…ç½®
func LoadFromFile(envFile string) (*Config, error) {
	loader := NewLoader(envFile)
	return loader.Load()
}

// LoadFromEnv ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®
func LoadFromEnv() (*Config, error) {
	loader := NewLoader("")
	return loader.Load()
}

// MustLoadFromFile ä»æ–‡ä»¶åŠ è½½é…ç½®ï¼Œå¤±è´¥æ—¶panic
func MustLoadFromFile(envFile string) *Config {
	cfg, err := LoadFromFile(envFile)
	if err != nil {
		panic(err)
	}
	return cfg
}

// GetEnvFile è·å–ç¯å¢ƒå˜é‡æ–‡ä»¶è·¯å¾„
func GetEnvFile() string {
	envFile := os.Getenv("ENV_FILE")
	if envFile == "" {
		envFile = ".env"
	}
	return envFile
}
```

## ğŸ§ª æµ‹è¯•éªŒè¯

### éªŒè¯æ­¥éª¤

1. **åˆ›å»ºæµ‹è¯•é…ç½®æ–‡ä»¶**
```bash
cp .env.example .env
```

2. **éªŒè¯é…ç½®åŠ è½½**
```bash
make build-server
./bin/server
```

3. **è¿è¡Œå•å…ƒæµ‹è¯•**
```bash
make test-unit
```

## ğŸ“‹ å®Œæˆæ£€æŸ¥æ¸…å•

- [ ] é…ç½®ç»“æ„ä½“å®šä¹‰å®Œæˆ
- [ ] ç¯å¢ƒå˜é‡åŠ è½½å™¨å®ç°å®Œæˆ
- [ ] é…ç½®éªŒè¯å™¨å®ç°å®Œæˆ
- [ ] é…ç½®åŠ è½½å™¨å®ç°å®Œæˆ
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] é›†æˆæµ‹è¯•é€šè¿‡
- [ ] æ–‡æ¡£æ›´æ–°å®Œæˆ

## ğŸ¯ ä¸‹ä¸€æ­¥è®¡åˆ’

å®Œæˆ Step 1.2 åï¼Œä¸‹ä¸€æ­¥å°†å®æ–½ **Step 1.3: æ—¥å¿—å’Œç›‘æ§åŸºç¡€**ï¼ŒåŒ…æ‹¬ï¼š
- å®ç°ç»“æ„åŒ–æ—¥å¿—è®°å½•å™¨ (pkg/logger/logger.go)
- é›†æˆ Prometheus æŒ‡æ ‡æ”¶é›† (pkg/metrics/prometheus.go)
- æ·»åŠ åŸºç¡€ä¸­é—´ä»¶ (internal/middleware/)

## ğŸ“ Git Commit ä¿¡æ¯

```bash
git add .
git commit -m "feat: implement configuration management system

- Add comprehensive configuration structures for all components
- Implement environment variable loader with reflection
- Add configuration validation with custom rules
- Create unified configuration loader with defaults
- Support for .env files and system environment variables
- Add validation for database, ethereum, and security configs
- Implement type-safe configuration loading

This provides a robust foundation for application configuration
management with validation and environment-specific settings."
```

---

**çŠ¶æ€**: âœ… å‡†å¤‡å®æ–½  
**é¢„ä¼°æ—¶é—´**: 3-4 å°æ—¶  
**ä¾èµ–**: Step 1.1 å®Œæˆ  
**ä¸‹ä¸€æ­¥**: Step 1.3 æ—¥å¿—å’Œç›‘æ§åŸºç¡€
